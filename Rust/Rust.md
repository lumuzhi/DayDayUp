## 变量绑定与解构

1. 使用下划线开头忽略未使用的变量

## 基本类型

#### 数值类型

1. 处理整型溢出

>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：
>
>- 使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
>- 如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
>- 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
>- 使用 `saturating_*` 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:
>
>```rust
>assert_eq!(100u8.saturating_add(1), 101);
>assert_eq!(u8::MAX.saturating_add(127), u8::MAX);
>```
>
>下面是一个演示`wrapping_*`方法的示例：
>
>```rust
>fn main() {
>    let a : u8 = 255;
>    let b = a.wrapping_add(20);
>    println!("{}", b);  // 19
>}
>```

2. 对于数学上未定义的结果，使用 NAN 来处理， is_nan()。
3. 使用 AS 完成类型转换。

#### 函数

1. 关键字 fn。
2. ！发散函数 永不返回。

## 所有权与借用

#### 所有权

> let s = "linwanrong"	// 字符串字面值 类型为&str，而动态字符串类型：String

可以使用下面的方法基于字符串字面量来创建 `String` 类型：

```rust
let s = String::from("hello");
```

- 基本类型（存储在栈上）自动拷贝。
- 注意区分克隆和拷贝，即深拷贝和浅拷贝。
- 任何基本类型的组合都有copy特征。

#### 引用与借用

获取变量的引用谓之借用。

引用与解引用

```rust
fn main() {
    let x = 5;
    let y = &x;	// 引用

    assert_eq!(5, x);
    assert_eq!(5, *y); // 解引用
}
```

可变引用与不可变引用，同一作用域可变引用只能有一个。可变引用与不可变引用不能同时存在。

> 注意，引用的作用域 `s` 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 `}`
